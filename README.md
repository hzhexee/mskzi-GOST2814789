# Реализация шифра ГОСТ 28147-89

## Описание

ГОСТ 28147-89 - это симметричный блочный шифр, разработанный в СССР и принятый в качестве стандарта в 1989 году. Алгоритм оперирует 64-битными блоками данных и использует 256-битный ключ. Данная реализация представляет собой программу на Python для шифрования и дешифрования текстовых данных по алгоритму ГОСТ 28147-89.

## Особенности алгоритма

- **Тип шифра**: Симметричный блочный шифр
- **Размер блока**: 64 бита
- **Размер ключа**: 256 бит
- **Количество раундов**: 32 раунда
- **Структура**: Сеть Фейстеля

## Основные компоненты реализации

### 1. S-блоки для подстановки (SBOX)

S-блоки используются для нелинейного преобразования 4-битных групп данных. В данной реализации используется 8 S-блоков, каждый из которых преобразует 4-битное число в другое 4-битное число.

```python
SBOX = [
    [4, 10, 9, 2, 13, 8, 0, 14, 6, 11, 1, 12, 7, 15, 5, 3],
    # ...другие S-блоки...
]
```

### 2. Циклический сдвиг влево (rot_left)

Функция выполняет циклический сдвиг 32-битного числа влево на указанное количество бит. В алгоритме ГОСТ используется сдвиг на 11 бит.

### 3. Дополнение сообщения (word_addition)

Функция дополняет сообщение символами 'a', чтобы его длина была кратна 8 байтам (64 битам), что необходимо для корректной работы с блоками.

### 4. Генерация раундовых ключей (round_keys)

В алгоритме ГОСТ ключ размером 256 бит разбивается на восемь 32-битных подключей. Порядок применения подключей зависит от операции:

- **Для шифрования**: K₀,K₁,...,K₇,K₀,K₁,...,K₇,K₀,K₁,...,K₇,K₇,K₆,...,K₀
- **Для дешифрования**: K₀,K₁,...,K₇,K₇,K₆,...,K₀,K₇,K₆,...,K₀,K₇,K₆,...,K₀

### 5. Шифрование блока (encrypt_block)

Основная функция, выполняющая шифрование одного 64-битного блока данных. Процесс шифрования включает:

1. Разделение блока на два 32-битных подблока (левый и правый)
2. Выполнение 32 раундов преобразований, в каждом из которых:
   - Сложение правого подблока с раундовым ключом по модулю 2³²
   - Применение S-блоков подстановки
   - Циклический сдвиг влево на 11 бит
   - Операция XOR (исключающее ИЛИ) с левым подблоком
   - Обмен местами подблоков для следующего раунда
3. Формирование итогового зашифрованного блока

### 6. Шифрование/дешифрование сообщения (crypt_message)

Функция, выполняющая шифрование или дешифрование всего сообщения. Процесс включает:

1. Дополнение сообщения до нужной длины
2. Преобразование сообщения в шестнадцатеричный формат (при шифровании)
3. Генерацию раундовых ключей
4. Разбиение сообщения на блоки по 64 бита
5. Шифрование/дешифрование каждого блока
6. Объединение результатов

## Процесс шифрования

### Этапы шифрования сообщения:

1. **Подготовка данных**:
   - Дополнение сообщения до кратности 8 байтам
   - Преобразование в шестнадцатеричный формат

2. **Подготовка ключа**:
   - Использование 256-битного ключа в шестнадцатеричном формате
   - Генерация 32 раундовых ключей

3. **Блочное шифрование**:
   - Разбиение сообщения на блоки по 64 бита
   - Шифрование каждого блока с использованием сети Фейстеля

4. **Результат**:
   - Зашифрованное сообщение в шестнадцатеричном формате

### Этапы дешифрования сообщения:

1. Использование того же 256-битного ключа
2. Генерация раундовых ключей в обратном порядке
3. Разбиение шифротекста на блоки по 64 бита
4. Применение алгоритма дешифрования (идентичен шифрованию, но с обратным порядком ключей)
5. Преобразование результата из шестнадцатеричного формата в текст

## Пример использования

```python
# Задаем сообщение и ключ
message = "Hello, world!"
key = "a55275ad61a2c973fe3727b26b9001d353bc0e51e12b2db0c55bfa9a87cfd32d"

# Шифрование
encrypted = crypt_message(message, key, 'e')
print(f"Зашифрованное сообщение: {encrypted}")

# Дешифрование
decrypted_hex = crypt_message(encrypted, key, 'd')
decrypted_text = binascii.unhexlify(decrypted_hex).decode()
print(f"Расшифрованное сообщение: {decrypted_text}")
```
